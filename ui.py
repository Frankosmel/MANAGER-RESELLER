from telethon import Button, types
from typing import List, Dict, Any
import logging

# Configurar logging para depuraci√≥n y auditor√≠a
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    filename="ui.log"
)

# ---------- Reply Keyboards ----------
def _b(t: str) -> types.KeyboardButton:
    """
    Crea un bot√≥n de teclado con el texto especificado.
    
    Args:
        t (str): Texto del bot√≥n.
    
    Returns:
        types.KeyboardButton: Bot√≥n de Telegram.
    """
    if not t:
        logging.warning("Intento de crear bot√≥n con texto vac√≠o.")
        raise ValueError("El texto del bot√≥n no puede estar vac√≠o.")
    return types.KeyboardButton(text=t)

def _row(*texts: str) -> types.KeyboardButtonRow:
    """
    Crea una fila de botones para un teclado.
    
    Args:
        texts: Textos de los botones en la fila.
    
    Returns:
        types.KeyboardButtonRow: Fila de botones.
    """
    if not texts:
        logging.warning("Intento de crear fila de botones vac√≠a.")
        raise ValueError("La fila de botones debe contener al menos un bot√≥n.")
    return types.KeyboardButtonRow(buttons=[_b(t) for t in texts])

def kb_boss() -> types.ReplyKeyboardMarkup:
    """
    Crea el teclado para el administrador (boss) con opciones de gesti√≥n.
    
    Returns:
        types.ReplyKeyboardMarkup: Teclado con botones para resellers, clientes, pagos, facturas y ajustes.
    """
    try:
        return types.ReplyKeyboardMarkup(
            rows=[
                _row("üíº Resellers", "üë• Clientes"),
                _row("üí≥ Pagos", "üßæ Facturas"),
                _row("‚öôÔ∏è Ajustes")
            ],
            resize=True
        )
    except Exception as e:
        logging.error(f"Error al crear kb_boss: {e}")
        raise

def kb_reseller() -> types.ReplyKeyboardMarkup:
    """
    Crea el teclado para resellers con opciones de gesti√≥n de clientes y pagos.
    
    Returns:
        types.ReplyKeyboardMarkup: Teclado con botones para clientes, creaci√≥n, pagos y soporte.
    """
    try:
        return types.ReplyKeyboardMarkup(
            rows=[
                _row("üë• Mis clientes", "‚ûï Crear cliente"),
                _row("üí≥ Pagar / Renovar", "üìû Soporte Boss")
            ],
            resize=True
        )
    except Exception as e:
        logging.error(f"Error al crear kb_reseller: {e}")
        raise

def kb_client() -> types.ReplyKeyboardMarkup:
    """
    Crea el teclado para clientes con opciones de gesti√≥n de su plan y soporte.
    
    Returns:
        types.ReplyKeyboardMarkup: Teclado con botones para plan, provisi√≥n, pagos y soporte.
    """
    try:
        return types.ReplyKeyboardMarkup(
            rows=[
                _row("üìÑ Mi plan", "‚öôÔ∏è Provisionar"),
                _row("üí≥ Pagar / Renovar", "üìû Soporte")
            ],
            resize=True
        )
    except Exception as e:
        logging.error(f"Error al crear kb_client: {e}")
        raise

# ---------- Inline Blocks ----------
def inline_plans_reseller(prices: Dict[str, float], rate: float) -> tuple[str, List[List[Button]]]:
    """
    Crea el texto y los botones inline para seleccionar un plan de reseller.
    
    Args:
        prices (Dict[str, float]): Diccionario con precios de planes (res_b, res_p, res_e).
        rate (float): Tasa de cambio USD a CUP.
    
    Returns:
        tuple[str, List[List[Button]]]: Texto con los planes y lista de botones inline.
    
    Raises:
        ValueError: Si faltan precios o la tasa es inv√°lida.
    """
    try:
        if not prices or not all(k in prices for k in ("res_b", "res_p", "res_e")):
            logging.error("Precios incompletos para inline_plans_reseller.")
            raise ValueError("Faltan precios para los planes de reseller.")
        if rate <= 0:
            logging.error(f"Tasa de cambio inv√°lida: {rate}")
            raise ValueError("La tasa de cambio debe ser mayor a 0.")

        text = (
            "üè∑ **Elige tu plan de Reseller**\n\n"
            f"‚Ä¢ **B√°sico**: {prices['res_b']} USD / {_fmt_money_cup(prices['res_b'] * rate)}\n"
            f"‚Ä¢ **Pro**: {prices['res_p']} USD / {_fmt_money_cup(prices['res_p'] * rate)}\n"
            f"‚Ä¢ **Enterprise**: {prices['res_e']} USD / {_fmt_money_cup(prices['res_e'] * rate)}\n\n"
            "Selecciona un plan para continuar:"
        )
        buttons = [
            [
                Button.inline("B√°sico", b"pay:res_b"),
                Button.inline("Pro", b"pay:res_p"),
                Button.inline("Enterprise", b"pay:res_e")
            ],
            [Button.inline("¬´ Volver atr√°s", b"pay:back")]
        ]
        logging.info("Botones inline de planes de reseller generados correctamente.")
        return text, buttons
    except Exception as e:
        logging.error(f"Error en inline_plans_reseller: {e}")
        raise

def inline_pay_methods(usd: float, cup: float) -> tuple[str, List[List[Button]]]:
    """
    Crea el texto y los botones inline para seleccionar el m√©todo de pago.
    
    Args:
        usd (float): Monto en USD.
        cup (float): Monto en CUP (calculado con la tasa de cambio).
    
    Returns:
        tuple[str, List[List[Button]]]: Texto con el monto y lista de botones inline.
    
    Raises:
        ValueError: Si los montos son inv√°lidos.
    """
    try:
        if usd <= 0 or cup <= 0:
            logging.error(f"Montos inv√°lidos: USD={usd}, CUP={cup}")
            raise ValueError("Los montos USD y CUP deben ser mayores a 0.")
        
        text = (
            "üí∞ **Confirmar pago**\n\n"
            f"‚Ä¢ Monto: **{usd} USD** ({_fmt_money_cup(cup)})\n"
            "Selecciona el m√©todo de pago:"
        )
        buttons = [
            [Button.inline("Saldo", b"pay:m:saldo"), Button.inline("CUP", b"pay:m:cup")],
            [Button.inline("¬´ Volver atr√°s", b"pay:plan")]
        ]
        logging.info(f"Botones inline de m√©todos de pago generados: USD={usd}, CUP={cup}")
        return text, buttons
    except Exception as e:
        logging.error(f"Error en inline_pay_methods: {e}")
        raise

def inline_client_terms(prices: Dict[str, float]) -> tuple[str, List[List[Button]]]:
    """
    Crea el texto y los botones inline para seleccionar la duraci√≥n de renovaci√≥n de un cliente.
    
    Args:
        prices (Dict[str, float]): Diccionario con precios de planes de cliente (c30, c90, c365).
    
    Returns:
        tuple[str, List[List[Button]]]: Texto con las duraciones y lista de botones inline.
    
    Raises:
        ValueError: Si faltan precios de planes.
    """
    try:
        if not prices or not all(k in prices for k in ("c30", "c90", "c365")):
            logging.error("Precios incompletos para inline_client_terms.")
            raise ValueError("Faltan precios para los planes de cliente.")
        
        text = (
            "üóì **Renovar plan de cliente**\n\n"
            f"‚Ä¢ 30 d√≠as: **{prices['c30']} USD**\n"
            f"‚Ä¢ 90 d√≠as: **{prices['c90']} USD**\n"
            f"‚Ä¢ 365 d√≠as: **{prices['c365']} USD**\n\n"
            "Selecciona la duraci√≥n del plan:"
        )
        buttons = [
            [
                Button.inline("30 d√≠as", b"pay:c:30"),
                Button.inline("90 d√≠as", b"pay:c:90"),
                Button.inline("365 d√≠as", b"pay:c:365")
            ],
            [Button.inline("¬´ Volver atr√°s", b"pay:back")]
        ]
        logging.info("Botones inline de t√©rminos de cliente generados correctamente.")
        return text, buttons
    except Exception as e:
        logging.error(f"Error en inline_client_terms: {e}")
        raise

def inline_pick_client(slugs: List[str]) -> List[List[Button]]:
    """
    Crea botones inline para seleccionar un cliente a partir de su slug.
    
    Args:
        slugs (List[str]): Lista de slugs de clientes.
    
    Returns:
        List[List[Button]]: Lista de filas de botones inline.
    
    Raises:
        ValueError: Si la lista de slugs est√° vac√≠a.
    """
    try:
        if not slugs:
            logging.warning("Lista de slugs vac√≠a en inline_pick_client.")
            raise ValueError("No hay clientes para seleccionar.")
        
        rows, row = [], []
        for s in slugs:
            row.append(Button.inline(f"üë§ {s}", f"pay:cli:{s}".encode()))
            if len(row) == 2:
                rows.append(row)
                row = []
        if row:
            rows.append(row)
        rows.append([Button.inline("¬´ Volver atr√°s", b"pay:back")])
        logging.info(f"Botones inline para {len(slugs)} clientes generados.")
        return rows
    except Exception as e:
        logging.error(f"Error en inline_pick_client: {e}")
        raise

def btn_send_receipt() -> List[List[Button]]:
    """
    Crea botones inline para enviar un comprobante de pago.
    
    Returns:
        List[List[Button]]: Lista de botones inline.
    """
    try:
        buttons = [
            [Button.inline("üì§ Enviar comprobante", b"pay:receipt")],
            [Button.inline("¬´ Volver atr√°s", b"pay:back")]
        ]
        logging.info("Botones inline de comprobante generados.")
        return buttons
    except Exception as e:
        logging.error(f"Error en btn_send_receipt: {e}")
        raise

# ---------- Pretty Formatters ----------
STATE_ICON = {
    "active": "üü¢ Activo",
    "stopped": "üî¥ Pausado",
    "unknown": "‚ö™ Desconocido"
}
STATUS_ICON = {
    "pending": "‚è≥ Pendiente",
    "approved": "‚úÖ Aprobado",
    "rejected": "‚ùå Rechazado"
}

def _fmt_money_cup(x: float) -> str:
    """
    Formatea un monto en CUP con separadores de miles.
    
    Args:
        x (float): Monto a formatear.
    
    Returns:
        str: Monto formateado (ej. "1,234 CUP").
    """
    try:
        return f"{int(x):,} CUP".replace(",", " ")
    except ValueError:
        logging.error(f"Error al formatear monto CUP: {x}")
        return "0 CUP"

def fmt_payments_pretty(rows: List[Dict[str, Any]]) -> str:
    """
    Formatea una lista de pagos en un texto legible para el administrador.
    
    Args:
        rows (List[Dict[str, Any]]): Lista de pagos con sus detalles.
    
    Returns:
        str: Texto formateado con los pagos.
    """
    try:
        if not rows:
            return "üßæ **Pagos recientes**\n\nNo hay pagos registrados."
        out = ["üßæ **Pagos recientes**\n"]
        for r in rows:
            out += [
                f"üî∏ **ID**: `{r['id']}`",
                f"   üìå **Estado**: {STATUS_ICON.get(r['status'], r['status'])}",
                f"   üíµ **Monto**: {r['amount_usd']} USD",
                f"   üí± **Equivalente**: {_fmt_money_cup(r['amount_cup'])}",
                f"   üë§ **Plan/Concepto**: {r['plan']}",
                f"   üõí **Item**: `{r['item_id']}`",
                f"   üÜî **Usuario**: `{r['user_id']}`",
                ""
            ]
        out.append("‚öôÔ∏è **Comandos disponibles**:\n- `/approve <id>`\n- `/reject <id> <motivo>`")
        logging.info(f"Formateo de {len(rows)} pagos completado.")
        return "\n".join(out)
    except Exception as e:
        logging.error(f"Error en fmt_payments_pretty: {e}")
        return "üßæ **Error al mostrar pagos**\nNo se pudieron formatear los pagos."

def fmt_resellers_list(rows: List[Dict[str, Any]]) -> str:
    """
    Formatea una lista de resellers en un texto legible para el administrador.
    
    Args:
        rows (List[Dict[str, Any]]): Lista de resellers con sus detalles.
    
    Returns:
        str: Texto formateado con los resellers.
    """
    try:
        if not rows:
            return "üíº **Resellers**\n\nNo hay resellers registrados."
        out = ["üíº **Lista de Resellers**\n"]
        for r in rows:
            out.append(
                f"üîπ **ID**: `{r['id']}` | **Plan**: {r['plan']} | **Vence**: {r['expires']} | "
                f"**Contacto**: {r.get('contact', 'N/A')} | **Clientes**: {r.get('clients', 0)}"
            )
        logging.info(f"Formateo de {len(rows)} resellers completado.")
        return "\n".join(out)
    except Exception as e:
        logging.error(f"Error en fmt_resellers_list: {e}")
        return "üíº **Error al mostrar resellers**\nNo se pudieron formatear los resellers."

def fmt_clients_list(rows: List[Dict[str, Any]], title: str = "üë• CLIENTES") -> str:
    """
    Formatea una lista de clientes en un texto legible.
    
    Args:
        rows (List[Dict[str, Any]]): Lista de clientes con sus detalles.
        title (str): T√≠tulo del listado (por defecto, "CLIENTES").
    
    Returns:
        str: Texto formateado con los clientes.
    """
    try:
        if not rows:
            return f"{title}\n\nNo hay clientes registrados."
        out = [f"{title}\n"]
        for c in rows:
            out.append(
                f"üîπ **Slug**: `{c['slug']}` | **Plan**: {c['plan']} | **Vence**: {c['expires']} | "
                f"**Reseller**: `{c['reseller_id']}`"
            )
        logging.info(f"Formateo de {len(rows)} clientes completado.")
        return "\n".join(out)
    except Exception as e:
        logging.error(f"Error en fmt_clients_list: {e}")
        return f"{title}\n\nError al mostrar los clientes."

def fmt_client_card(c: Dict[str, Any]) -> str:
    """
    Formatea los detalles de un cliente en una tarjeta informativa.
    
    Args:
        c (Dict[str, Any]): Detalles del cliente.
    
    Returns:
        str: Texto formateado con la informaci√≥n del cliente.
    """
    try:
        return (
            "üë§ **Informaci√≥n del Cliente**\n\n"
            f"üß≠ **Slug**: `{c['slug']}`\n"
            f"üÜî **Propietario**: `{c['owner_id']}` (@{c.get('username', 'N/A')})\n"
            f"üíº **Reseller**: `{c['reseller_id']}`\n"
            f"üè∑ **Plan**: {c['plan']}\n"
            f"üìÖ **Vence**: {c['expires']}\n"
            f"üóÇ **Directorio**: `{c['workdir']}`\n"
            f"üõ∞ **Estado del servicio**: {STATE_ICON.get(c.get('svc_status', 'unknown'), 'Desconocido')}"
        )
    except Exception as e:
        logging.error(f"Error en fmt_client_card: {e}")
        return "üë§ **Error al mostrar cliente**\nNo se pudieron formatear los datos."

def fmt_status_panel(s: Dict[str, Any]) -> str:
    """
    Formatea el panel de estado de un cliente o servicio.
    
    Args:
        s (Dict[str, Any]): Detalles del estado del cliente o servicio.
    
    Returns:
        str: Texto formateado con el estado.
    """
    try:
        return (
            "üìä **Estado del Servicio**\n\n"
            f"üè∑ **Plan**: {s['plan']}\n"
            f"üß≠ **Slug**: `{s['slug']}`\n"
            f"üìÖ **Vence**: {s['expires']}\n"
            f"üõ∞ **Servicio**: {STATE_ICON.get(s.get('svc', 'unknown'), 'Desconocido')}\n"
            f"ü§ñ **Bot**: @{s.get('bot', 'No configurado')}\n"
            f"üìÅ **Directorio**: `{s['workdir']}`"
        )
    except Exception as e:
        logging.error(f"Error en fmt_status_panel: {e}")
        return "üìä **Error al mostrar estado**\nNo se pudieron formatear los datos."

# ---------- Messages ----------
MSG_CLIENT_WELCOME = (
    "üöÄ **Bienvenido a tu Panel de Servicio**\n\n"
    "üîñ **Plan**: {plan}\n"
    "üìÖ **Vence**: {expires}\n"
    "üß≠ **ID**: `{slug}`\n\n"
    "üí° Usa **üí≥ Pagar / Renovar** para mantener tu servicio activo o **üìû Soporte** para ayuda."
)
MSG_RES_LIMIT = (
    "‚õî **L√≠mite de clientes alcanzado**\n"
    "Tu plan permite un m√°ximo de {limit} clientes.\n"
    "Actualiza tu plan en **üí≥ Pagar / Renovar** para crear m√°s."
)
MSG_PAY_PICK = (
    "üí≥ **Realizar un pago**\n\n"
    "Selecciona una opci√≥n:\n"
    "‚Ä¢ **Plan Reseller**: Actualiza o renueva tu plan (B√°sico, Pro, Enterprise).\n"
    "‚Ä¢ **Renovar Cliente**: Extiende el plan de un cliente existente (30, 90 o 365 d√≠as)."
)
MSG_PAY_SALDO = (
    "üíµ **Pagar con saldo**\n\n"
    "{txt}\n"
    "Monto: **{monto_saldo} CUP**\n\n"
    "1. Realiza el pago.\n"
    "2. Pulsa **üì§ Enviar comprobante** y adjunta la captura en el chat."
)
MSG_PAY_CUP = (
    "üíµ **Pagar en CUP**\n\n"
    "{txt}\n"
    "Monto: **{monto_cup} CUP**\n\n"
    "1. Realiza el pago.\n"
    "2. Pulsa **üì§ Enviar comprobante** y adjunta la captura en el chat."
)
MSG_RECEIPT_OK = (
    "‚úÖ **Comprobante recibido**\n"
    "Tu pago est√° en revisi√≥n. El administrador lo aprobar√° pronto.\n"
    "Te notificaremos cuando est√© listo."
)
MSG_EXPIRES_TMR = (
    "‚ö†Ô∏è **Recordatorio: ¬°Tu servicio vence ma√±ana!**\n"
    "‚Ä¢ **ID**: `{slug}`\n"
    "‚Ä¢ **Fecha**: {expires}\n\n"
    "Renueva ahora en **üí≥ Pagar / Renovar** para evitar interrupciones."
)
MSG_EXPIRED = (
    "üî¥ **Servicio pausado por vencimiento**\n"
    "‚Ä¢ **ID**: `{slug}`\n"
    "‚Ä¢ **Venci√≥**: {expires}\n\n"
    "Renueva en **üí≥ Pagar / Renovar** para reactivar tu servicio."
)
MSG_CREATED_CLIENT = (
    "‚úÖ **Cliente creado exitosamente**\n"
    "‚Ä¢ **Slug**: `{slug}`\n"
    "‚Ä¢ **Reseller**: `{rid}`\n"
    "‚Ä¢ **Vence**: `{expires}`\n\n"
    "Notifica al cliente con su slug para que pueda usar el servicio."
)
MSG_CREATED_RESELLER = (
    "‚úÖ **Reseller activado**\n"
    "‚Ä¢ **ID**: `{rid}`\n"
    "‚Ä¢ **Plan**: B√°sico\n"
    "‚Ä¢ **Vence**: `{expires}`\n\n"
    "¬°Listo para crear clientes y vender! Usa **üë• Mis clientes** o **‚ûï Crear cliente**."
        )
